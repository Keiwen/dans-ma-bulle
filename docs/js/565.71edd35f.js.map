{"version":3,"file":"js/565.71edd35f.js","mappings":"kQA6DA,MAAMA,EAAa,iBACbC,EAAe,SA0DRC,EAAN,MAAMA,EAOXC,WAAAA,CACUC,EACRC,GADQ,KAAAD,OAAAA,EANV,KAAQE,gBAAA,IAAsBC,IAC9B,KAAQC,eAAiB,EA4EzB,KAAQC,cAAiBC,IACvB,MAAMC,EAAWD,EAAME,KAGvB,GAAsB,UAAlBD,EAASE,KAGX,OAFAC,KAAKC,OAAOC,MAAMhB,EAAYC,EAAc,wBAC5Ca,KAAKG,UAAUC,SAAQ,GAIzB,MAAMC,EAAOL,KAAKR,gBAAgBc,IAAIT,EAASU,IAE/C,GAAKF,EASL,OAAQR,EAASE,MACf,IAAK,SACHC,KAAKC,OAAOC,MAAMhB,EAAYC,EAAc,uBAAuBU,EAASU,MAC5EF,EAAKD,QAAQP,EAASC,MACtBE,KAAKR,gBAAgBgB,OAAOX,EAASU,IACrC,MAEF,IAAK,QACHP,KAAKC,OAAOC,MACVhB,EACAC,EACA,sBAAsBU,EAASU,MAC/BV,EAASY,OAEPZ,EAASY,MACXJ,EAAKK,KAAKb,EAASY,OAEnBJ,EAAKM,OAAO,CAAEC,KAAMC,EAAAA,GAAaC,QAASC,QAAS,kBAErDf,KAAKR,gBAAgBgB,OAAOX,EAASU,IACrC,MAEF,IAAK,WACHP,KAAKC,OAAOC,MAAMhB,EAAYC,EAAc,yBAAyBU,EAASU,MAC9EF,EAAKW,SAASnB,EAASmB,UACvB,WAjCFhB,KAAKC,OAAOgB,KACV/B,EACAC,EACA,0CAA0CU,EAASU,OApFvDP,KAAKC,OAASV,EAAQU,QAAU,IAAIiB,EAAAA,GACpClB,KAAKV,OAAO6B,iBAAiB,UAAWnB,KAAKL,eAG7CK,KAAKG,UAAY,IAAIiB,EAAAA,GACrBpB,KAAKR,gBAAgB6B,IAAIjC,EAAekC,cAAetB,KAAKG,WAG5DH,KAAKV,OAAOiC,YAAY,CACtBhB,GAAInB,EAAekC,cACnBvB,KAAM,WACNyB,QAASjC,EAAQiC,QACjBvB,OAAQV,EAAQU,QAASwB,EAAAA,EAAAA,IAAgBlC,EAAQU,aAAU,EAC3DyB,aAAcnC,EAAQmC,eAGxB1B,KAAKC,OAAOC,MAAMhB,EAAYC,EAAc,yBAC9C,CAKQwC,UAAAA,GACN,MAAO,OAAOC,KAAKC,SAAS7B,KAAKN,kBACnC,CAMQoC,IAAAA,CAAqBC,EAAqBC,GAChD,MAAMzB,EAAKP,KAAK2B,aACVtB,EAAO,IAAIe,EAAAA,GAEXa,EAAyB,CAC7B1B,KACAR,KAAM,UACNgC,SACAC,QAwBF,OApBAhC,KAAKG,UAAU+B,KACb,KACElC,KAAKR,gBAAgB6B,IAAId,EAAIF,GAC7BL,KAAKC,OAAOC,MAAMhB,EAAYC,EAAc,WAAW4C,aAAmBxB,GAC1EP,KAAKV,OAAOiC,YAAYU,IAEzBxB,IACCT,KAAKC,OAAOQ,MACVvB,EACAC,EACA,iCAAiC4C,KACjCtB,GAEFJ,EAAKM,OAAO,CACVC,KAAMC,EAAAA,GAAasB,eACnBpB,QAAS,mCAKRV,CACT,CA0DA+B,OAAAA,GACEpC,KAAKV,OAAO+C,oBAAoB,UAAWrC,KAAKL,eAGhDK,KAAKR,gBAAgB8C,QAAQ,CAACjC,EAAME,KAC9BA,IAAOnB,EAAekC,gBACxBjB,EAAKkC,MAAM,oBACXvC,KAAKC,OAAOC,MAAMhB,EAAYC,EAAc,4BAA4BoB,QAG5EP,KAAKR,gBAAgBgD,QAErBxC,KAAKV,OAAOmD,YACZzC,KAAKC,OAAOC,MAAMhB,EAAYC,EAAc,2BAC9C,CAIAuD,kBAAAA,CACEC,EACApD,GAEA,OAAOS,KAAK8B,KAAwB,qBAAsB,CAACa,EAAMpD,GACnE,CAEAqD,WAAAA,CAAYC,GACV,OAAO7C,KAAK8B,KAAwB,cAAe,CAACe,GACtD,CAEAC,WAAAA,CAAYD,EAAwBE,GAClC,OAAO/C,KAAK8B,KAAc,cAAe,CAACe,EAAKE,GACjD,CAEAC,iBAAAA,CAAkBH,GAChB,OAAO7C,KAAK8B,KAAa,oBAAqB,CAACe,GACjD,CAEAI,qBAAAA,CAAsBJ,GACpB,OAAO7C,KAAK8B,KAAa,wBAAyB,CAACe,GACrD,CAEAK,aAAAA,CAAcL,GACZ,OAAO7C,KAAK8B,KAA2B,gBAAiB,CAACe,GAC3D,CAEAM,YAAAA,CAAaN,GACX,OAAO7C,KAAK8B,KAAyB,eAAgB,CAACe,GACxD,CAEAO,YAAAA,CAAaP,EAAwBQ,GACnC,OAAOrD,KAAK8B,KAAc,eAAgB,CAACe,EAAKQ,GAClD,CAEAC,eAAAA,CAAgBT,GACd,OAAO7C,KAAK8B,KAAc,kBAAmB,CAACe,GAChD,CAEAU,aAAAA,CACEV,EACAW,EACAjE,GAEA,OAAOS,KAAK8B,KAAoB,gBAAiB,CAACe,EAAKW,EAAMjE,GAC/D,CAEAkE,cAAAA,CACEZ,EACAW,EACAE,EACAnE,GAEA,OAAOS,KAAK8B,KAAoB,iBAAkB,CAACe,EAAKW,EAAME,EAAMnE,GACtE,CAEAoE,kBAAAA,CACEd,EACAW,EACAjE,GAEA,OAAOS,KAAK8B,KAAoB,qBAAsB,CAACe,EAAKW,EAAMjE,GACpE,CAEAqE,uBAAAA,CACEf,EACAW,EACAK,EACAtE,GAEA,OAAOS,KAAK8B,KAAoB,0BAA2B,CAACe,EAAKW,EAAMK,EAAYtE,GACrF,CAEAuE,qBAAAA,CACEjB,EACAW,GAEA,OAAOxD,KAAK8B,KAA4B,wBAAyB,CAACe,EAAKW,GACzE,CAEAO,kBAAAA,CAAmBlB,EAAwBW,GACzC,OAAOxD,KAAK8B,KAA4B,qBAAsB,CAACe,EAAKW,GACtE,CAEAQ,oBAAAA,CACEnB,EACAW,EACAK,EACAI,GAEA,OAAOjE,KAAK8B,KAAa,uBAAwB,CAACe,EAAKW,EAAMK,EAAYI,GAC3E,CAEAC,oBAAAA,CACErB,EACAW,EACAK,GAEA,OAAO7D,KAAK8B,KAAc,uBAAwB,CAACe,EAAKW,EAAMK,GAChE,CAEAM,oBAAAA,CACEtB,EACAW,EACAK,GAEA,OAAO7D,KAAK8B,KAAc,uBAAwB,CAACe,EAAKW,EAAMK,GAChE,CAEAO,gBAAAA,CAAiBvB,EAAwBW,GACvC,OAAOxD,KAAK8B,KAA0B,mBAAoB,CAACe,EAAKW,GAClE,CAEAa,YAAAA,CACExB,EACAW,EACAc,EACAC,GAEA,OAAOvE,KAAK8B,KAAqB,eAAgB,CAACe,EAAKW,EAAMc,EAASC,GACxE,CAEAC,mBAAAA,CACE3B,EACA4B,GAEA,OAAOzE,KAAK8B,KACV,sBACA,CAACe,EAAK4B,GAEV,CAEAC,WAAAA,CACE7B,EACA4B,EACAH,EACAC,GAEA,OAAOvE,KAAK8B,KAAoE,cAAe,CAC7Fe,EACA4B,EACAH,EACAC,GAEJ,CAEAI,cAAAA,CAAe9B,GACb,OAAO7C,KAAK8B,KAA4B,iBAAkB,CAACe,GAC7D,CAEA+B,aAAAA,CAAc/B,EAAwBgC,GACpC,OAAO7E,KAAK8B,KAAc,gBAAiB,CAACe,EAAKgC,GACnD,CAEAC,gBAAAA,CAAiBjC,EAAwBkC,GACvC,OAAO/E,KAAK8B,KAAc,mBAAoB,CAACe,EAAKkC,GACtD,CAEAC,qBAAAA,CACEnC,EACAkC,GAEA,OAAO/E,KAAK8B,KAAkB,wBAAyB,CAACe,EAAKkC,GAC/D,CAEAE,iBAAAA,CACEpC,EACAW,EACAK,EACAqB,GAEA,OAAOlF,KAAK8B,KAAc,oBAAqB,CAACe,EAAKW,EAAMK,EAAYqB,GACzE,CAEAC,WAAAA,CACEtC,EACAW,EACAjE,GAEA,OAAOS,KAAK8B,KAA2B,cAAe,CAACe,EAAKW,EAAMjE,GACpE,CAEA6F,YAAAA,CAAavC,EAAwBwC,GACnC,OAAOrF,KAAK8B,KAAkB,eAAgB,CAACe,EAAKwC,GACtD,CAEAC,WAAAA,CAAYzC,EAAwBwC,GAClC,OAAOrF,KAAK8B,KAAa,cAAe,CAACe,EAAKwC,GAChD,CAEAE,iBAAAA,CACE1C,EACAW,EACAgC,EACAjG,GAEA,OAAOS,KAAK8B,KAAc,oBAAqB,CAACe,EAAKW,EAAMgC,EAAOjG,GACpE,CAEAkG,aAAAA,CAAc5C,EAAwB6C,GACpC,OAAO1F,KAAK8B,KAAe,gBAAiB,CAACe,EAAK6C,GACpD,CAEAC,aAAAA,CAAc9C,EAAwBW,GACpC,OAAOxD,KAAK8B,KAAuB,gBAAiB,CAACe,EAAKW,GAC5D,CAEAoC,eAAAA,CAAgB/C,EAAwBW,GACtC,OAAOxD,KAAK8B,KAAsB,kBAAmB,CAACe,EAAKW,GAC7D,CAEAqC,KAAAA,CAAMC,GACJ,OAAO9F,KAAK8B,KAAc,QAAS,CAACgE,GACtC,CAEAC,UAAAA,CAAWC,GACT,OAAOhG,KAAK8B,KAAc,aAAc,CAACkE,GAC3C,CAEAC,oBAAAA,CAAqBpD,EAAwBtD,GAC3C,OAAOS,KAAK8B,KAAkB,uBAAwB,CAACe,EAAKtD,GAC9D,CAEA2G,UAAAA,CAAWrD,GACT,OAAO7C,KAAK8B,KAAkB,aAAc,CAACe,GAC/C,CAEAsD,aAAAA,CAActD,GACZ,OAAO7C,KAAK8B,KAAc,gBAAiB,CAACe,GAC9C,CAEAuD,iBAAAA,GACE,OAAOpG,KAAK8B,KAAc,oBAAqB,GACjD,GA9XA1C,EAAekC,cAAgB,IAD1B,IAAM+E,EAANjH,ECrHP,MAAMkH,EAAa,mBACbC,EAAe,UAWd,MAAMC,EAaXnH,WAAAA,CACUoH,EAAmB,EACnBC,EACRzG,GAFQ,KAAAwG,SAAAA,EACA,KAAAC,UAAAA,EAdV,KAAQC,QAAoB,GAC5B,KAAQC,aAAA,IAAmBnH,IAC3B,KAAQoH,aAAe,EACvB,KAAQnH,eAAiB,EAcvBM,KAAKC,OAASA,GAAU,IAAIiB,EAAAA,GAC5BlB,KAAK8G,YACP,CAKQA,UAAAA,GACN9G,KAAKC,OAAOC,MACVoG,EACAC,EACA,6BAA6BvG,KAAKyG,oBAGpC,QAASM,EAAI,EAAGA,EAAI/G,KAAKyG,SAAUM,IACjC,IACE,MAAMzH,EAAS,IAAI0H,OAAOhH,KAAK0G,UAAW,CAAE3G,KAAM,WAClDT,EAAO2H,UAAYjH,KAAKkH,oBAAoBC,KAAKnH,MACjDV,EAAO8H,QAAUpH,KAAKqH,kBAAkBF,KAAKnH,MAC7CA,KAAK2G,QAAQW,KAAKhI,GAElBU,KAAKC,OAAOC,MAAMoG,EAAYC,EAAc,UAAUQ,yBACxD,CAAC,MAAQtG,GACPT,KAAKC,OAAOQ,MAAM6F,EAAYC,EAAc,2BAA2BQ,KAAMtG,EAC/E,CAEJ,CAKQyG,mBAAAA,CAAoBtH,GAC1B,MAAMC,EAAWD,EAAME,KACjBO,EAAOL,KAAK4G,aAAatG,IAAIT,EAASU,IAE5C,GAAKF,EAWL,GAFAL,KAAK4G,aAAapG,OAAOX,EAASU,IAEZ,WAAlBV,EAASE,KACXM,EAAKD,QAAQP,EAASC,UACjB,CACL,MAAMyH,EAAY1H,EAASC,KAC3BO,EAAKM,OAAO,IAAI6G,MAAMD,EAAUxG,SAClC,MAfEf,KAAKC,OAAOgB,KACVqF,EACAC,EACA,uCAAuC1G,EAASU,KAatD,CAKQ8G,iBAAAA,CAAkB5G,GACxBT,KAAKC,OAAOQ,MAAM6F,EAAYC,EAAc,gBAAiB9F,EAAMM,QACrE,CAKQ0G,aAAAA,GACN,GAA4B,IAAxBzH,KAAK2G,QAAQe,OACf,OAAO,KAGT,MAAMpI,EAASU,KAAK2G,QAAQ3G,KAAK6G,cAEjC,OADA7G,KAAK6G,cAAgB7G,KAAK6G,aAAe,GAAK7G,KAAK2G,QAAQe,OACpDpI,CACT,CASAqI,MAAAA,CACEC,EACAC,EAAuD,aACvDC,GAEA,OAAO,IAAIC,QAAQ,CAAC3H,EAASO,KAC3B,MAAMrB,EAASU,KAAKyH,gBAEpB,IAAKnI,EAEH,YADAqB,EAAO,IAAI6G,MAAM,qCAInB,MAAMQ,EAAY,UAAUpG,KAAKC,SAAS7B,KAAKN,mBAC/CM,KAAK4G,aAAavF,IAAI2G,EAAW,CAAE5H,UAASO,WAE5C,MAAMsB,EAA8B,CAClC1B,GAAIyH,EACJjI,KAAM,SACND,KAAM,CACJ8H,UAAW,CACT9H,KAAM8H,EAAU9H,KAChBmI,MAAOL,EAAUK,MACjBC,OAAQN,EAAUM,QAEpBL,YACAC,YAIJ9H,KAAKC,OAAOC,MACVoG,EACAC,EACA,4BAA4ByB,MAAcJ,EAAUK,SAASL,EAAUM,WAIzE5I,EAAOiC,YAAYU,EAAS,CAAC2F,EAAU9H,KAAKqI,UAEhD,CAKA/F,OAAAA,GACEpC,KAAKC,OAAOC,MAAMoG,EAAYC,EAAc,0BAG5CvG,KAAK4G,aAAatE,QAAQ,CAACjC,EAAME,KAC/BF,EAAKM,OAAO,IAAI6G,MAAM,0BACtBxH,KAAKC,OAAOC,MAAMoG,EAAYC,EAAc,0BAA0BhG,OAExEP,KAAK4G,aAAapE,QAGlBxC,KAAK2G,QAAQrE,QAAQ,CAAChD,EAAQ8I,KAC5B9I,EAAOmD,YACPzC,KAAKC,OAAOC,MAAMoG,EAAYC,EAAc,UAAU6B,kBAExDpI,KAAK2G,QAAU,EACjB,CAKA,iBAAI0B,GACF,OAAOrI,KAAK2G,QAAQe,MACtB,CAKA,qBAAIY,GACF,OAAOtI,KAAK4G,aAAa2B,IAC3B,E","sources":["webpack://dans-ma-bulle/../../../src/lib/orchestrator/remote-executor.ts","webpack://dans-ma-bulle/../../../src/lib/image-encoder/worker-pool.ts"],"sourcesContent":["import {\n  BatchProgress,\n  Logger,\n  NoopLogger,\n  PdfDocumentObject,\n  PdfPageObject,\n  PdfTask,\n  PdfErrorReason,\n  PdfFile,\n  PdfOpenDocumentBufferOptions,\n  PdfMetadataObject,\n  PdfBookmarksObject,\n  PdfBookmarkObject,\n  PdfRenderPageOptions,\n  PdfRenderThumbnailOptions,\n  PdfRenderPageAnnotationOptions,\n  PdfAnnotationObject,\n  PdfTextRectObject,\n  PdfAttachmentObject,\n  PdfAddAttachmentParams,\n  PdfWidgetAnnoObject,\n  FormFieldValue,\n  PdfFlattenPageOptions,\n  PdfPageFlattenResult,\n  PdfRedactTextOptions,\n  Rect,\n  PageTextSlice,\n  PdfGlyphObject,\n  PdfPageGeometry,\n  PdfPrintOptions,\n  PdfSignatureObject,\n  AnnotationCreateContext,\n  Task,\n  TaskError,\n  PdfErrorCode,\n  SearchResult,\n  serializeLogger,\n  IPdfiumExecutor,\n  ImageDataLike,\n} from '@embedpdf/models';\nimport type { WorkerRequest, WorkerResponse } from './pdfium-native-runner';\nimport type { FontFallbackConfig } from '../pdfium/font-fallback';\n\n/**\n * Options for creating a RemoteExecutor\n */\nexport interface RemoteExecutorOptions {\n  /**\n   * URL to the pdfium.wasm file (required)\n   */\n  wasmUrl: string;\n  /**\n   * Logger instance for debugging\n   */\n  logger?: Logger;\n  /**\n   * Font fallback configuration for handling missing fonts\n   */\n  fontFallback?: FontFallbackConfig;\n}\n\nconst LOG_SOURCE = 'RemoteExecutor';\nconst LOG_CATEGORY = 'Worker';\n\n/**\n * Message types for worker communication\n */\ntype MessageType =\n  | 'destroy'\n  | 'openDocumentBuffer'\n  | 'getMetadata'\n  | 'setMetadata'\n  | 'getDocPermissions'\n  | 'getDocUserPermissions'\n  | 'getSignatures'\n  | 'getBookmarks'\n  | 'setBookmarks'\n  | 'deleteBookmarks'\n  | 'renderPageRaw'\n  | 'renderPageRect'\n  | 'renderThumbnailRaw'\n  | 'renderPageAnnotationRaw'\n  | 'getPageAnnotations'\n  | 'getPageAnnotationsRaw'\n  | 'createPageAnnotation'\n  | 'updatePageAnnotation'\n  | 'removePageAnnotation'\n  | 'getPageTextRects'\n  | 'searchInPage'\n  | 'getAnnotationsBatch'\n  | 'searchBatch'\n  | 'getAttachments'\n  | 'addAttachment'\n  | 'removeAttachment'\n  | 'readAttachmentContent'\n  | 'setFormFieldValue'\n  | 'flattenPage'\n  | 'extractPages'\n  | 'extractText'\n  | 'redactTextInRects'\n  | 'getTextSlices'\n  | 'getPageGlyphs'\n  | 'getPageGeometry'\n  | 'merge'\n  | 'mergePages'\n  | 'preparePrintDocument'\n  | 'saveAsCopy'\n  | 'closeDocument'\n  | 'closeAllDocuments';\n\n/**\n * RemoteExecutor - Proxy for worker communication\n *\n * This implements IPdfExecutor but forwards all calls to a Web Worker.\n * It handles:\n * - Serialization/deserialization of messages\n * - Promise/Task conversion\n * - Error handling\n * - Progress tracking\n */\nexport class RemoteExecutor implements IPdfiumExecutor {\n  private static READY_TASK_ID = '0';\n  private pendingRequests = new Map<string, Task<any, any>>();\n  private requestCounter = 0;\n  private logger: Logger;\n  private readyTask: Task<boolean, PdfErrorReason>;\n\n  constructor(\n    private worker: Worker,\n    options: RemoteExecutorOptions,\n  ) {\n    this.logger = options.logger ?? new NoopLogger();\n    this.worker.addEventListener('message', this.handleMessage);\n\n    // Create ready task - will be resolved when worker sends 'ready'\n    this.readyTask = new Task<boolean, PdfErrorReason>();\n    this.pendingRequests.set(RemoteExecutor.READY_TASK_ID, this.readyTask);\n\n    // Send initialization message with WASM URL and font fallback config\n    this.worker.postMessage({\n      id: RemoteExecutor.READY_TASK_ID,\n      type: 'wasmInit',\n      wasmUrl: options.wasmUrl,\n      logger: options.logger ? serializeLogger(options.logger) : undefined,\n      fontFallback: options.fontFallback,\n    });\n\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'RemoteExecutor created');\n  }\n\n  /**\n   * Generate unique request ID\n   */\n  private generateId(): string {\n    return `req-${Date.now()}-${this.requestCounter++}`;\n  }\n\n  /**\n   * Send a message to the worker and return a Task\n   * Waits for worker to be ready before sending\n   */\n  private send<T, P = unknown>(method: MessageType, args: any[]): Task<T, PdfErrorReason, P> {\n    const id = this.generateId();\n    const task = new Task<T, PdfErrorReason, P>();\n\n    const request: WorkerRequest = {\n      id,\n      type: 'execute',\n      method,\n      args,\n    };\n\n    // Wait for worker to be ready before sending\n    this.readyTask.wait(\n      () => {\n        this.pendingRequests.set(id, task);\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Sending ${method} request:`, id);\n        this.worker.postMessage(request);\n      },\n      (error) => {\n        this.logger.error(\n          LOG_SOURCE,\n          LOG_CATEGORY,\n          `Worker init failed, rejecting ${method}:`,\n          error,\n        );\n        task.reject({\n          code: PdfErrorCode.Initialization,\n          message: 'Worker initialization failed',\n        });\n      },\n    );\n\n    return task;\n  }\n\n  /**\n   * Handle messages from worker\n   */\n  private handleMessage = (event: MessageEvent<WorkerResponse>) => {\n    const response = event.data;\n\n    // Handle ready response - resolve the readyTask\n    if (response.type === 'ready') {\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'Worker is ready');\n      this.readyTask.resolve(true);\n      return;\n    }\n\n    const task = this.pendingRequests.get(response.id);\n\n    if (!task) {\n      this.logger.warn(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `Received response for unknown request: ${response.id}`,\n      );\n      return;\n    }\n\n    switch (response.type) {\n      case 'result':\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Received result for ${response.id}`);\n        task.resolve(response.data);\n        this.pendingRequests.delete(response.id);\n        break;\n\n      case 'error':\n        this.logger.debug(\n          LOG_SOURCE,\n          LOG_CATEGORY,\n          `Received error for ${response.id}:`,\n          response.error,\n        );\n        if (response.error) {\n          task.fail(response.error);\n        } else {\n          task.reject({ code: PdfErrorCode.Unknown, message: 'Unknown error' });\n        }\n        this.pendingRequests.delete(response.id);\n        break;\n\n      case 'progress':\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Received progress for ${response.id}`);\n        task.progress(response.progress);\n        break;\n    }\n  };\n\n  /**\n   * Cleanup and terminate worker\n   */\n  destroy(): void {\n    this.worker.removeEventListener('message', this.handleMessage);\n\n    // Reject all pending requests (except readyTask)\n    this.pendingRequests.forEach((task, id) => {\n      if (id !== RemoteExecutor.READY_TASK_ID) {\n        task.abort('Worker destroyed');\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Aborted pending request: ${id}`);\n      }\n    });\n    this.pendingRequests.clear();\n\n    this.worker.terminate();\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'RemoteExecutor destroyed');\n  }\n\n  // ========== IPdfExecutor Implementation ==========\n\n  openDocumentBuffer(\n    file: PdfFile,\n    options?: PdfOpenDocumentBufferOptions,\n  ): PdfTask<PdfDocumentObject> {\n    return this.send<PdfDocumentObject>('openDocumentBuffer', [file, options]);\n  }\n\n  getMetadata(doc: PdfDocumentObject): PdfTask<PdfMetadataObject> {\n    return this.send<PdfMetadataObject>('getMetadata', [doc]);\n  }\n\n  setMetadata(doc: PdfDocumentObject, metadata: Partial<PdfMetadataObject>): PdfTask<boolean> {\n    return this.send<boolean>('setMetadata', [doc, metadata]);\n  }\n\n  getDocPermissions(doc: PdfDocumentObject): PdfTask<number> {\n    return this.send<number>('getDocPermissions', [doc]);\n  }\n\n  getDocUserPermissions(doc: PdfDocumentObject): PdfTask<number> {\n    return this.send<number>('getDocUserPermissions', [doc]);\n  }\n\n  getSignatures(doc: PdfDocumentObject): PdfTask<PdfSignatureObject[]> {\n    return this.send<PdfSignatureObject[]>('getSignatures', [doc]);\n  }\n\n  getBookmarks(doc: PdfDocumentObject): PdfTask<PdfBookmarksObject> {\n    return this.send<PdfBookmarksObject>('getBookmarks', [doc]);\n  }\n\n  setBookmarks(doc: PdfDocumentObject, bookmarks: PdfBookmarkObject[]): PdfTask<boolean> {\n    return this.send<boolean>('setBookmarks', [doc, bookmarks]);\n  }\n\n  deleteBookmarks(doc: PdfDocumentObject): PdfTask<boolean> {\n    return this.send<boolean>('deleteBookmarks', [doc]);\n  }\n\n  renderPageRaw(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    options?: PdfRenderPageOptions,\n  ): PdfTask<ImageDataLike> {\n    return this.send<ImageDataLike>('renderPageRaw', [doc, page, options]);\n  }\n\n  renderPageRect(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    rect: Rect,\n    options?: PdfRenderPageOptions,\n  ): PdfTask<ImageDataLike> {\n    return this.send<ImageDataLike>('renderPageRect', [doc, page, rect, options]);\n  }\n\n  renderThumbnailRaw(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    options?: PdfRenderThumbnailOptions,\n  ): PdfTask<ImageDataLike> {\n    return this.send<ImageDataLike>('renderThumbnailRaw', [doc, page, options]);\n  }\n\n  renderPageAnnotationRaw(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n    options?: PdfRenderPageAnnotationOptions,\n  ): PdfTask<ImageDataLike> {\n    return this.send<ImageDataLike>('renderPageAnnotationRaw', [doc, page, annotation, options]);\n  }\n\n  getPageAnnotationsRaw(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n  ): PdfTask<PdfAnnotationObject[]> {\n    return this.send<PdfAnnotationObject[]>('getPageAnnotationsRaw', [doc, page]);\n  }\n\n  getPageAnnotations(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfAnnotationObject[]> {\n    return this.send<PdfAnnotationObject[]>('getPageAnnotations', [doc, page]);\n  }\n\n  createPageAnnotation<A extends PdfAnnotationObject>(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: A,\n    context?: AnnotationCreateContext<A>,\n  ): PdfTask<string> {\n    return this.send<string>('createPageAnnotation', [doc, page, annotation, context]);\n  }\n\n  updatePageAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ): PdfTask<boolean> {\n    return this.send<boolean>('updatePageAnnotation', [doc, page, annotation]);\n  }\n\n  removePageAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ): PdfTask<boolean> {\n    return this.send<boolean>('removePageAnnotation', [doc, page, annotation]);\n  }\n\n  getPageTextRects(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfTextRectObject[]> {\n    return this.send<PdfTextRectObject[]>('getPageTextRects', [doc, page]);\n  }\n\n  searchInPage(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    keyword: string,\n    flags: number,\n  ): PdfTask<SearchResult[]> {\n    return this.send<SearchResult[]>('searchInPage', [doc, page, keyword, flags]);\n  }\n\n  getAnnotationsBatch(\n    doc: PdfDocumentObject,\n    pages: PdfPageObject[],\n  ): PdfTask<Record<number, PdfAnnotationObject[]>, BatchProgress<PdfAnnotationObject[]>> {\n    return this.send<Record<number, PdfAnnotationObject[]>, BatchProgress<PdfAnnotationObject[]>>(\n      'getAnnotationsBatch',\n      [doc, pages],\n    );\n  }\n\n  searchBatch(\n    doc: PdfDocumentObject,\n    pages: PdfPageObject[],\n    keyword: string,\n    flags: number,\n  ): PdfTask<Record<number, SearchResult[]>, BatchProgress<SearchResult[]>> {\n    return this.send<Record<number, SearchResult[]>, BatchProgress<SearchResult[]>>('searchBatch', [\n      doc,\n      pages,\n      keyword,\n      flags,\n    ]);\n  }\n\n  getAttachments(doc: PdfDocumentObject): PdfTask<PdfAttachmentObject[]> {\n    return this.send<PdfAttachmentObject[]>('getAttachments', [doc]);\n  }\n\n  addAttachment(doc: PdfDocumentObject, params: PdfAddAttachmentParams): PdfTask<boolean> {\n    return this.send<boolean>('addAttachment', [doc, params]);\n  }\n\n  removeAttachment(doc: PdfDocumentObject, attachment: PdfAttachmentObject): PdfTask<boolean> {\n    return this.send<boolean>('removeAttachment', [doc, attachment]);\n  }\n\n  readAttachmentContent(\n    doc: PdfDocumentObject,\n    attachment: PdfAttachmentObject,\n  ): PdfTask<ArrayBuffer> {\n    return this.send<ArrayBuffer>('readAttachmentContent', [doc, attachment]);\n  }\n\n  setFormFieldValue(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfWidgetAnnoObject,\n    value: FormFieldValue,\n  ): PdfTask<boolean> {\n    return this.send<boolean>('setFormFieldValue', [doc, page, annotation, value]);\n  }\n\n  flattenPage(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    options?: PdfFlattenPageOptions,\n  ): PdfTask<PdfPageFlattenResult> {\n    return this.send<PdfPageFlattenResult>('flattenPage', [doc, page, options]);\n  }\n\n  extractPages(doc: PdfDocumentObject, pageIndexes: number[]): PdfTask<ArrayBuffer> {\n    return this.send<ArrayBuffer>('extractPages', [doc, pageIndexes]);\n  }\n\n  extractText(doc: PdfDocumentObject, pageIndexes: number[]): PdfTask<string> {\n    return this.send<string>('extractText', [doc, pageIndexes]);\n  }\n\n  redactTextInRects(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    rects: Rect[],\n    options?: PdfRedactTextOptions,\n  ): PdfTask<boolean> {\n    return this.send<boolean>('redactTextInRects', [doc, page, rects, options]);\n  }\n\n  getTextSlices(doc: PdfDocumentObject, slices: PageTextSlice[]): PdfTask<string[]> {\n    return this.send<string[]>('getTextSlices', [doc, slices]);\n  }\n\n  getPageGlyphs(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfGlyphObject[]> {\n    return this.send<PdfGlyphObject[]>('getPageGlyphs', [doc, page]);\n  }\n\n  getPageGeometry(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfPageGeometry> {\n    return this.send<PdfPageGeometry>('getPageGeometry', [doc, page]);\n  }\n\n  merge(files: PdfFile[]): PdfTask<PdfFile> {\n    return this.send<PdfFile>('merge', [files]);\n  }\n\n  mergePages(mergeConfigs: Array<{ docId: string; pageIndices: number[] }>): PdfTask<PdfFile> {\n    return this.send<PdfFile>('mergePages', [mergeConfigs]);\n  }\n\n  preparePrintDocument(doc: PdfDocumentObject, options?: PdfPrintOptions): PdfTask<ArrayBuffer> {\n    return this.send<ArrayBuffer>('preparePrintDocument', [doc, options]);\n  }\n\n  saveAsCopy(doc: PdfDocumentObject): PdfTask<ArrayBuffer> {\n    return this.send<ArrayBuffer>('saveAsCopy', [doc]);\n  }\n\n  closeDocument(doc: PdfDocumentObject): PdfTask<boolean> {\n    return this.send<boolean>('closeDocument', [doc]);\n  }\n\n  closeAllDocuments(): PdfTask<boolean> {\n    return this.send<boolean>('closeAllDocuments', []);\n  }\n}\n","import { Logger, NoopLogger } from '@embedpdf/models';\nimport type { EncodeImageRequest, EncodeImageResponse } from './image-encoder-worker';\n\nconst LOG_SOURCE = 'ImageEncoderPool';\nconst LOG_CATEGORY = 'Encoder';\n\ninterface EncodingTask {\n  resolve: (blob: Blob) => void;\n  reject: (error: Error) => void;\n}\n\n/**\n * Pool of image encoding workers to offload OffscreenCanvas operations\n * from the main PDFium worker thread\n */\nexport class ImageEncoderWorkerPool {\n  private workers: Worker[] = [];\n  private pendingTasks = new Map<string, EncodingTask>();\n  private nextWorkerId = 0;\n  private requestCounter = 0;\n  private logger: Logger;\n\n  /**\n   * Create a pool of image encoding workers\n   * @param poolSize - Number of workers to create (default: 2)\n   * @param workerUrl - URL to the worker script\n   * @param logger - Logger instance\n   */\n  constructor(\n    private poolSize: number = 2,\n    private workerUrl: string,\n    logger?: Logger,\n  ) {\n    this.logger = logger ?? new NoopLogger();\n    this.initialize();\n  }\n\n  /**\n   * Initialize the worker pool\n   */\n  private initialize() {\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `Creating worker pool with ${this.poolSize} workers`,\n    );\n\n    for (let i = 0; i < this.poolSize; i++) {\n      try {\n        const worker = new Worker(this.workerUrl, { type: 'module' });\n        worker.onmessage = this.handleWorkerMessage.bind(this);\n        worker.onerror = this.handleWorkerError.bind(this);\n        this.workers.push(worker);\n\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Worker ${i} created successfully`);\n      } catch (error) {\n        this.logger.error(LOG_SOURCE, LOG_CATEGORY, `Failed to create worker ${i}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Handle messages from workers\n   */\n  private handleWorkerMessage(event: MessageEvent<EncodeImageResponse>) {\n    const response = event.data;\n    const task = this.pendingTasks.get(response.id);\n\n    if (!task) {\n      this.logger.warn(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `Received response for unknown task: ${response.id}`,\n      );\n      return;\n    }\n\n    this.pendingTasks.delete(response.id);\n\n    if (response.type === 'result') {\n      task.resolve(response.data as Blob);\n    } else {\n      const errorData = response.data as { message: string };\n      task.reject(new Error(errorData.message));\n    }\n  }\n\n  /**\n   * Handle worker errors\n   */\n  private handleWorkerError(error: ErrorEvent) {\n    this.logger.error(LOG_SOURCE, LOG_CATEGORY, 'Worker error:', error.message);\n  }\n\n  /**\n   * Get the next available worker using round-robin\n   */\n  private getNextWorker(): Worker | null {\n    if (this.workers.length === 0) {\n      return null;\n    }\n\n    const worker = this.workers[this.nextWorkerId];\n    this.nextWorkerId = (this.nextWorkerId + 1) % this.workers.length;\n    return worker;\n  }\n\n  /**\n   * Encode ImageData to Blob using a worker from the pool\n   * @param imageData - Raw image data\n   * @param imageType - Target image format\n   * @param quality - Image quality (0-1) for lossy formats\n   * @returns Promise that resolves to encoded Blob\n   */\n  encode(\n    imageData: { data: Uint8ClampedArray; width: number; height: number },\n    imageType: 'image/png' | 'image/jpeg' | 'image/webp' = 'image/webp',\n    quality?: number,\n  ): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      const worker = this.getNextWorker();\n\n      if (!worker) {\n        reject(new Error('No workers available in the pool'));\n        return;\n      }\n\n      const requestId = `encode-${Date.now()}-${this.requestCounter++}`;\n      this.pendingTasks.set(requestId, { resolve, reject });\n\n      const request: EncodeImageRequest = {\n        id: requestId,\n        type: 'encode',\n        data: {\n          imageData: {\n            data: imageData.data,\n            width: imageData.width,\n            height: imageData.height,\n          },\n          imageType,\n          quality,\n        },\n      };\n\n      this.logger.debug(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `Sending encoding request ${requestId} (${imageData.width}x${imageData.height})`,\n      );\n\n      // Transfer the buffer for better performance\n      worker.postMessage(request, [imageData.data.buffer]);\n    });\n  }\n\n  /**\n   * Destroy all workers in the pool\n   */\n  destroy() {\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'Destroying worker pool');\n\n    // Reject all pending tasks\n    this.pendingTasks.forEach((task, id) => {\n      task.reject(new Error('Worker pool destroyed'));\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Rejected pending task: ${id}`);\n    });\n    this.pendingTasks.clear();\n\n    // Terminate all workers\n    this.workers.forEach((worker, index) => {\n      worker.terminate();\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Worker ${index} terminated`);\n    });\n    this.workers = [];\n  }\n\n  /**\n   * Get the number of active workers in the pool\n   */\n  get activeWorkers(): number {\n    return this.workers.length;\n  }\n\n  /**\n   * Get the number of pending encoding tasks\n   */\n  get pendingTasksCount(): number {\n    return this.pendingTasks.size;\n  }\n}\n"],"names":["LOG_SOURCE$1","LOG_CATEGORY$1","_RemoteExecutor","constructor","worker","options","pendingRequests","Map","requestCounter","handleMessage","event","response","data","type","this","logger","debug","readyTask","resolve","task","get","id","delete","error","fail","reject","code","PdfErrorCode","Unknown","message","progress","warn","NoopLogger","addEventListener","Task","set","READY_TASK_ID","postMessage","wasmUrl","serializeLogger","fontFallback","generateId","Date","now","send","method","args","request","wait","Initialization","destroy","removeEventListener","forEach","abort","clear","terminate","openDocumentBuffer","file","getMetadata","doc","setMetadata","metadata","getDocPermissions","getDocUserPermissions","getSignatures","getBookmarks","setBookmarks","bookmarks","deleteBookmarks","renderPageRaw","page","renderPageRect","rect","renderThumbnailRaw","renderPageAnnotationRaw","annotation","getPageAnnotationsRaw","getPageAnnotations","createPageAnnotation","context","updatePageAnnotation","removePageAnnotation","getPageTextRects","searchInPage","keyword","flags","getAnnotationsBatch","pages","searchBatch","getAttachments","addAttachment","params","removeAttachment","attachment","readAttachmentContent","setFormFieldValue","value","flattenPage","extractPages","pageIndexes","extractText","redactTextInRects","rects","getTextSlices","slices","getPageGlyphs","getPageGeometry","merge","files","mergePages","mergeConfigs","preparePrintDocument","saveAsCopy","closeDocument","closeAllDocuments","RemoteExecutor","LOG_SOURCE","LOG_CATEGORY","ImageEncoderWorkerPool","poolSize","workerUrl","workers","pendingTasks","nextWorkerId","initialize","i","Worker","onmessage","handleWorkerMessage","bind","onerror","handleWorkerError","push","errorData","Error","getNextWorker","length","encode","imageData","imageType","quality","Promise","requestId","width","height","buffer","index","activeWorkers","pendingTasksCount","size"],"ignoreList":[],"sourceRoot":""}