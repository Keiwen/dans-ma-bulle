{"version":3,"file":"js/44.6b3e2a1d.js","mappings":"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","sources":["webpack://dans-ma-bulle/../src/lib/converters/browser.ts","webpack://dans-ma-bulle/../src/lib/orchestrator/task-queue.ts","webpack://dans-ma-bulle/../src/lib/orchestrator/pdf-engine.ts"],"sourcesContent":["import type { ImageConversionTypes } from '@embedpdf/models';\nimport type { ImageDataConverter, LazyImageData } from './types';\nimport { ImageEncoderWorkerPool } from '../image-encoder';\n\n// ============================================================================\n// Error Classes\n// ============================================================================\n\nexport class ImageConverterError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ImageConverterError';\n  }\n}\n\n// ============================================================================\n// Browser Converters\n// ============================================================================\n\n/**\n * Main-thread Canvas-based image converter\n * Simple and works everywhere, but blocks the main thread during encoding\n *\n * Use this as a fallback when worker-based encoding isn't available\n */\nexport const browserImageDataToBlobConverter: ImageDataConverter<Blob> = (\n  getImageData: LazyImageData,\n  imageType: ImageConversionTypes = 'image/webp',\n  quality?: number,\n): Promise<Blob> => {\n  if (typeof document === 'undefined') {\n    return Promise.reject(\n      new ImageConverterError(\n        'document is not available. This converter requires a browser environment.',\n      ),\n    );\n  }\n\n  const pdfImage = getImageData();\n  const imageData = new ImageData(pdfImage.data, pdfImage.width, pdfImage.height);\n\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    canvas.width = imageData.width;\n    canvas.height = imageData.height;\n    canvas.getContext('2d')!.putImageData(imageData, 0, 0);\n\n    canvas.toBlob(\n      (blob) => {\n        if (blob) {\n          resolve(blob);\n        } else {\n          reject(new ImageConverterError('Canvas toBlob returned null'));\n        }\n      },\n      imageType,\n      quality,\n    );\n  });\n};\n\n/**\n * Worker pool image converter using OffscreenCanvas in dedicated workers\n * Non-blocking - encoding happens off the main thread\n *\n * This is the preferred approach for performance\n *\n * @param workerPool - Instance of ImageEncoderWorkerPool\n * @returns ImageDataConverter function\n */\nexport function createWorkerPoolImageConverter(\n  workerPool: ImageEncoderWorkerPool,\n): ImageDataConverter<Blob> {\n  return (\n    getImageData: LazyImageData,\n    imageType: ImageConversionTypes = 'image/webp',\n    quality?: number,\n  ): Promise<Blob> => {\n    const pdfImage = getImageData();\n\n    // Copy the data since we'll transfer it to another worker\n    const dataCopy = new Uint8ClampedArray(pdfImage.data);\n\n    return workerPool.encode(\n      {\n        data: dataCopy,\n        width: pdfImage.width,\n        height: pdfImage.height,\n      },\n      imageType,\n      quality,\n    );\n  };\n}\n\n/**\n * Hybrid converter: Worker pool (OffscreenCanvas) â†’ Main thread Canvas fallback\n *\n * Best of both worlds:\n * - Primary: Non-blocking worker-based encoding with OffscreenCanvas\n * - Fallback: Main-thread Canvas for older browsers without OffscreenCanvas in workers\n *\n * @param workerPool - Instance of ImageEncoderWorkerPool\n * @returns ImageDataConverter function\n */\nexport function createHybridImageConverter(\n  workerPool: ImageEncoderWorkerPool,\n): ImageDataConverter<Blob> {\n  return async (\n    getImageData: LazyImageData,\n    imageType: ImageConversionTypes = 'image/webp',\n    quality?: number,\n  ): Promise<Blob> => {\n    try {\n      // Try worker pool encoding first (OffscreenCanvas in worker)\n      const pdfImage = getImageData();\n      const dataCopy = new Uint8ClampedArray(pdfImage.data);\n\n      return await workerPool.encode(\n        {\n          data: dataCopy,\n          width: pdfImage.width,\n          height: pdfImage.height,\n        },\n        imageType,\n        quality,\n      );\n    } catch (error) {\n      // Fallback to main-thread Canvas\n      console.warn('Worker encoding failed, falling back to main-thread Canvas:', error);\n      return browserImageDataToBlobConverter(getImageData, imageType, quality);\n    }\n  };\n}\n","import { Task, TaskError, Logger, NoopLogger } from '@embedpdf/models';\n\nconst LOG_SOURCE = 'TaskQueue';\nconst LOG_CATEGORY = 'Queue';\n\nexport enum Priority {\n  CRITICAL = 3,\n  HIGH = 2,\n  MEDIUM = 1,\n  LOW = 0,\n}\n\n// ============================================================================\n// Type Utilities\n// ============================================================================\n\n/**\n * Extract result type from Task\n */\nexport type ExtractTaskResult<T> = T extends Task<infer R, any, any> ? R : never;\n\n/**\n * Extract error type from Task\n */\nexport type ExtractTaskError<T> = T extends Task<any, infer D, any> ? D : never;\n\n/**\n * Extract progress type from Task\n */\nexport type ExtractTaskProgress<T> = T extends Task<any, any, infer P> ? P : never;\n\n// ============================================================================\n// Queue Interfaces\n// ============================================================================\n\nexport interface QueuedTask<T extends Task<any, any, any>> {\n  id: string;\n  priority: Priority;\n  meta?: Record<string, unknown>;\n  executeFactory: () => T; // Factory function - called when it's time to execute!\n  cancelled?: boolean;\n}\n\nexport interface EnqueueOptions {\n  priority?: Priority;\n  meta?: Record<string, unknown>;\n  fifo?: boolean;\n}\n\nexport type TaskComparator = (a: QueuedTask<any>, b: QueuedTask<any>) => number;\nexport type TaskRanker = (task: QueuedTask<any>) => number;\n\nexport interface WorkerTaskQueueOptions {\n  concurrency?: number;\n  comparator?: TaskComparator;\n  ranker?: TaskRanker;\n  onIdle?: () => void;\n  maxQueueSize?: number;\n  autoStart?: boolean;\n  logger?: Logger;\n}\n\n// ============================================================================\n// WorkerTaskQueue - Corrected with Deferred Execution\n// ============================================================================\n\nexport class WorkerTaskQueue {\n  private queue: QueuedTask<any>[] = [];\n  private running = 0;\n  private resultTasks = new Map<string, Task<any, any, any>>();\n  private logger: Logger;\n  private opts: Required<Omit<WorkerTaskQueueOptions, 'comparator' | 'ranker' | 'logger'>> & {\n    comparator?: TaskComparator;\n    ranker?: TaskRanker;\n  };\n\n  constructor(options: WorkerTaskQueueOptions = {}) {\n    const {\n      concurrency = 1,\n      comparator,\n      ranker,\n      onIdle,\n      maxQueueSize,\n      autoStart = true,\n      logger,\n    } = options;\n    this.logger = logger ?? new NoopLogger();\n    this.opts = {\n      concurrency: Math.max(1, concurrency),\n      comparator,\n      ranker,\n      onIdle: onIdle ?? (() => {}),\n      maxQueueSize: maxQueueSize ?? Number.POSITIVE_INFINITY,\n      autoStart,\n    };\n  }\n\n  setComparator(comparator?: TaskComparator): void {\n    this.opts.comparator = comparator;\n  }\n\n  setRanker(ranker?: TaskRanker): void {\n    this.opts.ranker = ranker;\n  }\n\n  size(): number {\n    return this.queue.length;\n  }\n\n  inFlight(): number {\n    return this.running;\n  }\n\n  isIdle(): boolean {\n    return this.queue.length === 0 && this.running === 0;\n  }\n\n  async drain(): Promise<void> {\n    if (this.isIdle()) return;\n    await new Promise<void>((resolve) => {\n      const check = () => {\n        if (this.isIdle()) {\n          this.offIdle(check);\n          resolve();\n        }\n      };\n      this.onIdle(check);\n    });\n  }\n\n  private idleListeners = new Set<() => void>();\n  private notifyIdle() {\n    if (this.isIdle()) {\n      [...this.idleListeners].forEach((fn) => fn());\n      this.idleListeners.clear();\n      this.opts.onIdle();\n    }\n  }\n  private onIdle(fn: () => void) {\n    this.idleListeners.add(fn);\n  }\n  private offIdle(fn: () => void) {\n    this.idleListeners.delete(fn);\n  }\n\n  /**\n   * Enqueue a task factory - with automatic type inference!\n   *\n   * The factory function is ONLY called when it's the task's turn to execute.\n   *\n   * Usage:\n   *   const task = queue.enqueue({\n   *     execute: () => this.executor.getMetadata(doc),  // Factory - not called yet!\n   *     meta: { operation: 'getMetadata' }\n   *   }, { priority: Priority.LOW });\n   *\n   * The returned task has the SAME type as executor.getMetadata() would return!\n   */\n  enqueue<T extends Task<any, any, any>>(\n    taskDef: {\n      execute: () => T; // Factory function that returns Task when called!\n      meta?: Record<string, unknown>;\n    },\n    options: EnqueueOptions = {},\n  ): T {\n    const id = this.generateId();\n    const priority = options.priority ?? Priority.MEDIUM;\n\n    // Create a proxy task that we return to the user\n    // This task bridges to the real task that will be created later\n    const resultTask = new Task<\n      ExtractTaskResult<T>,\n      ExtractTaskError<T>,\n      ExtractTaskProgress<T>\n    >() as T;\n\n    if (this.queue.length >= this.opts.maxQueueSize) {\n      const error = new Error('Queue is full (maxQueueSize reached).');\n      resultTask.reject(error as any);\n      return resultTask;\n    }\n\n    // Store the result task for bridging\n    this.resultTasks.set(id, resultTask);\n\n    const queuedTask: QueuedTask<T> = {\n      id,\n      priority,\n      meta: options.meta ?? taskDef.meta,\n      executeFactory: taskDef.execute, // Store factory, don't call it yet!\n    };\n\n    this.queue.push(queuedTask);\n\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `Task enqueued: ${id} | Priority: ${priority} | Running: ${this.running} | Queued: ${this.queue.length}`,\n    );\n\n    // Set up automatic abort handling\n    // When result task is aborted externally, remove from queue\n    const originalAbort = resultTask.abort.bind(resultTask);\n    resultTask.abort = (reason: any) => {\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Task aborted: ${id}`);\n      this.cancel(id);\n      originalAbort(reason);\n    };\n\n    if (this.opts.autoStart) this.process(options.fifo === true);\n\n    return resultTask;\n  }\n\n  /**\n   * Cancel/remove a task from the queue\n   */\n  private cancel(taskId: string): void {\n    const before = this.queue.length;\n    this.queue = this.queue.filter((t) => {\n      if (t.id === taskId) {\n        t.cancelled = true;\n        return false;\n      }\n      return true;\n    });\n\n    this.resultTasks.delete(taskId);\n\n    if (before !== this.queue.length) {\n      this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Task cancelled and removed: ${taskId}`);\n      this.kick();\n    }\n  }\n\n  private kick() {\n    queueMicrotask(() => this.process());\n  }\n\n  private async process(fifo = false): Promise<void> {\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `process() called | Running: ${this.running} | Concurrency: ${this.opts.concurrency} | Queued: ${this.queue.length}`,\n    );\n\n    while (this.running < this.opts.concurrency && this.queue.length > 0) {\n      this.logger.debug(\n        LOG_SOURCE,\n        LOG_CATEGORY,\n        `Starting new task | Running: ${this.running} | Queued: ${this.queue.length}`,\n      );\n\n      if (!fifo) this.sortQueue();\n\n      const queuedTask = this.queue.shift()!;\n      if (queuedTask.cancelled) {\n        this.logger.debug(LOG_SOURCE, LOG_CATEGORY, `Skipping cancelled task: ${queuedTask.id}`);\n        continue;\n      }\n\n      const resultTask = this.resultTasks.get(queuedTask.id);\n      if (!resultTask) continue; // Shouldn't happen, but guard anyway.\n\n      this.running++;\n\n      // NOW call the factory to create the real task!\n      (async () => {\n        let realTask: Task<any, any, any> | null = null;\n\n        try {\n          // Call the factory function NOW - this is when execution actually starts\n          realTask = queuedTask.executeFactory();\n\n          // Guard against null/undefined return from factory\n          if (!realTask) {\n            throw new Error('Task factory returned null/undefined');\n          }\n\n          // Bridge the real task to the result task\n          realTask.wait(\n            (result) => {\n              if (resultTask.state.stage === 0 /* Pending */) {\n                resultTask.resolve(result);\n              }\n            },\n            (error) => {\n              if (resultTask.state.stage === 0 /* Pending */) {\n                if (error.type === 'abort') {\n                  resultTask.abort(error.reason);\n                } else {\n                  resultTask.reject(error.reason);\n                }\n              }\n            },\n          );\n\n          // Bridge progress\n          realTask.onProgress((progress) => {\n            resultTask.progress(progress);\n          });\n\n          // Wait for completion\n          await realTask.toPromise();\n        } catch (error) {\n          // Handle any errors from factory or execution\n          if (resultTask.state.stage === 0 /* Pending */) {\n            resultTask.reject(error as any);\n          }\n        } finally {\n          this.resultTasks.delete(queuedTask.id);\n          this.running--;\n\n          this.logger.debug(\n            LOG_SOURCE,\n            LOG_CATEGORY,\n            `Task completed: ${queuedTask.id} | Running: ${this.running} | Queued: ${this.queue.length}`,\n          );\n\n          if (this.isIdle()) {\n            this.notifyIdle();\n          } else if (this.queue.length > 0) {\n            this.kick();\n          }\n        }\n      })().catch((error) => {\n        this.logger.error(\n          LOG_SOURCE,\n          LOG_CATEGORY,\n          'Unhandled error in task execution wrapper:',\n          error,\n        );\n        this.running = Math.max(0, this.running - 1);\n        if (this.isIdle()) {\n          this.notifyIdle();\n        } else if (this.queue.length > 0) {\n          this.kick();\n        }\n      });\n    }\n  }\n\n  private sortQueue(): void {\n    const { comparator, ranker } = this.opts;\n    if (comparator) {\n      this.queue.sort(comparator);\n      return;\n    }\n\n    const rankCache = new Map<string, number>();\n    const getRank = (t: QueuedTask<any>) => {\n      if (!ranker) return this.defaultRank(t);\n      if (!rankCache.has(t.id)) rankCache.set(t.id, ranker(t));\n      return rankCache.get(t.id)!;\n    };\n\n    this.queue.sort((a, b) => {\n      if (a.priority !== b.priority) return b.priority - a.priority;\n      const ar = getRank(a);\n      const br = getRank(b);\n      if (ar !== br) return br - ar;\n      return this.extractTime(a.id) - this.extractTime(b.id);\n    });\n  }\n\n  private defaultRank(_task: QueuedTask<any>): number {\n    return 0;\n  }\n\n  private generateId(): string {\n    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {\n      return crypto.randomUUID();\n    }\n    return `${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  }\n\n  private extractTime(id: string): number {\n    const t = Number(id.split('-')[0]);\n    return Number.isFinite(t) ? t : 0;\n  }\n}\n","import {\n  BatchProgress,\n  Logger,\n  NoopLogger,\n  PdfEngine as IPdfEngine,\n  PdfDocumentObject,\n  PdfPageObject,\n  PdfTask,\n  PdfErrorReason,\n  PdfFileUrl,\n  PdfFile,\n  PdfOpenDocumentUrlOptions,\n  PdfOpenDocumentBufferOptions,\n  PdfMetadataObject,\n  PdfBookmarksObject,\n  PdfBookmarkObject,\n  PdfRenderPageOptions,\n  PdfRenderThumbnailOptions,\n  PdfRenderPageAnnotationOptions,\n  PdfAnnotationObject,\n  PdfTextRectObject,\n  PdfSearchAllPagesOptions,\n  SearchAllPagesResult,\n  PdfPageSearchProgress,\n  PdfAnnotationsProgress,\n  PdfAttachmentObject,\n  PdfAddAttachmentParams,\n  PdfWidgetAnnoObject,\n  FormFieldValue,\n  PdfFlattenPageOptions,\n  PdfPageFlattenResult,\n  PdfRedactTextOptions,\n  Rect,\n  PageTextSlice,\n  PdfGlyphObject,\n  PdfPageGeometry,\n  PdfPrintOptions,\n  PdfEngineFeature,\n  PdfEngineOperation,\n  PdfSignatureObject,\n  AnnotationCreateContext,\n  Task,\n  PdfErrorCode,\n  SearchResult,\n  CompoundTask,\n  ImageDataLike,\n  IPdfiumExecutor,\n} from '@embedpdf/models';\nimport { WorkerTaskQueue, Priority } from './task-queue';\nimport type { ImageDataConverter } from '../converters/types';\n\n// Re-export for convenience\nexport type { ImageDataConverter } from '../converters/types';\nexport type { ImageDataLike, IPdfiumExecutor, BatchProgress } from '@embedpdf/models';\n\nconst LOG_SOURCE = 'PdfEngine';\nconst LOG_CATEGORY = 'Orchestrator';\n\nexport interface PdfEngineOptions<T> {\n  /**\n   * Image data converter (for encoding raw image data to Blob/other format)\n   */\n  imageConverter: ImageDataConverter<T>;\n  /**\n   * Fetch function for fetching remote URLs\n   */\n  fetcher?: typeof fetch;\n  /**\n   * Logger instance\n   */\n  logger?: Logger;\n}\n\n/**\n * PdfEngine orchestrator\n *\n * This is the \"smart\" layer that:\n * - Implements the PdfEngine interface\n * - Uses WorkerTaskQueue for priority-based task scheduling\n * - Orchestrates complex multi-page operations\n * - Handles image encoding with separate encoder pool\n * - Manages visibility-based task ranking\n */\nexport class PdfEngine<T = Blob> implements IPdfEngine<T> {\n  private executor: IPdfiumExecutor;\n  private workerQueue: WorkerTaskQueue;\n  private logger: Logger;\n  private options: PdfEngineOptions<T>;\n\n  constructor(executor: IPdfiumExecutor, options: PdfEngineOptions<T>) {\n    this.executor = executor;\n    this.logger = options.logger ?? new NoopLogger();\n    this.options = {\n      imageConverter: options.imageConverter,\n      fetcher:\n        options.fetcher ??\n        (typeof fetch !== 'undefined' ? (url, init) => fetch(url, init) : undefined),\n      logger: this.logger,\n    };\n\n    // Create worker queue with single concurrency (PDFium is single-threaded)\n    this.workerQueue = new WorkerTaskQueue({\n      concurrency: 1,\n      autoStart: true,\n      logger: this.logger,\n    });\n\n    this.logger.debug(LOG_SOURCE, LOG_CATEGORY, 'PdfEngine orchestrator created');\n  }\n\n  /**\n   * Split an array into chunks of a given size\n   */\n  private chunkArray<U>(items: U[], chunkSize: number): U[][] {\n    const chunks: U[][] = [];\n    for (let i = 0; i < items.length; i += chunkSize) {\n      chunks.push(items.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n\n  // ========== IPdfEngine Implementation ==========\n\n  isSupport(feature: PdfEngineFeature): PdfTask<PdfEngineOperation[]> {\n    const task = new Task<PdfEngineOperation[], PdfErrorReason>();\n    // PDFium supports all features\n    task.resolve([\n      PdfEngineOperation.Create,\n      PdfEngineOperation.Read,\n      PdfEngineOperation.Update,\n      PdfEngineOperation.Delete,\n    ]);\n    return task;\n  }\n\n  destroy(): PdfTask<boolean> {\n    const task = new Task<boolean, PdfErrorReason>();\n    try {\n      this.executor.destroy();\n      task.resolve(true);\n    } catch (error) {\n      task.reject({ code: PdfErrorCode.Unknown, message: String(error) });\n    }\n    return task;\n  }\n\n  openDocumentUrl(\n    file: PdfFileUrl,\n    options?: PdfOpenDocumentUrlOptions,\n  ): PdfTask<PdfDocumentObject> {\n    const task = new Task<PdfDocumentObject, PdfErrorReason>();\n\n    // Handle fetch in main thread (not worker!)\n    (async () => {\n      try {\n        if (!this.options.fetcher) {\n          throw new Error('Fetcher is not set');\n        }\n\n        const response = await this.options.fetcher(file.url, options?.requestOptions);\n        const arrayBuf = await response.arrayBuffer();\n\n        const pdfFile: PdfFile = {\n          id: file.id,\n          content: arrayBuf,\n        };\n\n        // Then open in worker - use wait() to properly propagate task errors\n        this.openDocumentBuffer(pdfFile, {\n          password: options?.password,\n        }).wait(\n          (doc) => task.resolve(doc),\n          (error) => task.fail(error),\n        );\n      } catch (error) {\n        // This only catches fetch errors (network issues, etc.)\n        task.reject({ code: PdfErrorCode.Unknown, message: String(error) });\n      }\n    })();\n\n    return task;\n  }\n\n  openDocumentBuffer(\n    file: PdfFile,\n    options?: PdfOpenDocumentBufferOptions,\n  ): PdfTask<PdfDocumentObject> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.openDocumentBuffer(file, options),\n        meta: { docId: file.id, operation: 'openDocumentBuffer' },\n      },\n      { priority: Priority.CRITICAL },\n    );\n  }\n\n  getMetadata(doc: PdfDocumentObject): PdfTask<PdfMetadataObject> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getMetadata(doc),\n        meta: { docId: doc.id, operation: 'getMetadata' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  setMetadata(doc: PdfDocumentObject, metadata: Partial<PdfMetadataObject>): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.setMetadata(doc, metadata),\n        meta: { docId: doc.id, operation: 'setMetadata' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  getDocPermissions(doc: PdfDocumentObject): PdfTask<number> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getDocPermissions(doc),\n        meta: { docId: doc.id, operation: 'getDocPermissions' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  getDocUserPermissions(doc: PdfDocumentObject): PdfTask<number> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getDocUserPermissions(doc),\n        meta: { docId: doc.id, operation: 'getDocUserPermissions' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  getSignatures(doc: PdfDocumentObject): PdfTask<PdfSignatureObject[]> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getSignatures(doc),\n        meta: { docId: doc.id, operation: 'getSignatures' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  getBookmarks(doc: PdfDocumentObject): PdfTask<PdfBookmarksObject> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getBookmarks(doc),\n        meta: { docId: doc.id, operation: 'getBookmarks' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  setBookmarks(doc: PdfDocumentObject, bookmarks: PdfBookmarkObject[]): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.setBookmarks(doc, bookmarks),\n        meta: { docId: doc.id, operation: 'setBookmarks' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  deleteBookmarks(doc: PdfDocumentObject): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.deleteBookmarks(doc),\n        meta: { docId: doc.id, operation: 'deleteBookmarks' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  // ========== Rendering with Encoding ==========\n\n  renderPage(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    options?: PdfRenderPageOptions,\n  ): PdfTask<T> {\n    return this.renderWithEncoding(\n      () => this.executor.renderPageRaw(doc, page, options),\n      options,\n      doc.id,\n      page.index,\n      Priority.CRITICAL,\n    );\n  }\n\n  renderPageRect(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    rect: Rect,\n    options?: PdfRenderPageOptions,\n  ): PdfTask<T> {\n    return this.renderWithEncoding(\n      () => this.executor.renderPageRect(doc, page, rect, options),\n      options,\n      doc.id,\n      page.index,\n      Priority.HIGH,\n    );\n  }\n\n  renderThumbnail(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    options?: PdfRenderThumbnailOptions,\n  ): PdfTask<T> {\n    return this.renderWithEncoding(\n      () => this.executor.renderThumbnailRaw(doc, page, options),\n      options,\n      doc.id,\n      page.index,\n      Priority.MEDIUM,\n    );\n  }\n\n  renderPageAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n    options?: PdfRenderPageAnnotationOptions,\n  ): PdfTask<T> {\n    return this.renderWithEncoding(\n      () => this.executor.renderPageAnnotationRaw(doc, page, annotation, options),\n      options,\n      doc.id,\n      page.index,\n      Priority.MEDIUM,\n    );\n  }\n\n  /**\n   * Helper to render and encode in two stages with priority queue\n   */\n  private renderWithEncoding(\n    renderFn: () => PdfTask<ImageDataLike>,\n    options?: PdfRenderPageOptions | PdfRenderThumbnailOptions | PdfRenderPageAnnotationOptions,\n    docId?: string,\n    pageIndex?: number,\n    priority: Priority = Priority.CRITICAL,\n  ): PdfTask<T> {\n    const resultTask = new Task<T, PdfErrorReason>();\n\n    // Step 1: Add HIGH/MEDIUM priority task to render raw bytes\n    const renderHandle = this.workerQueue.enqueue(\n      {\n        execute: () => renderFn(),\n        meta: { docId, pageIndex, operation: 'render' },\n      },\n      { priority },\n    );\n\n    // Wire up abort: when resultTask is aborted, also abort the queue task\n    const originalAbort = resultTask.abort.bind(resultTask);\n    resultTask.abort = (reason) => {\n      renderHandle.abort(reason); // Cancel the queue task!\n      originalAbort(reason);\n    };\n\n    renderHandle.wait(\n      (rawImageData) => {\n        // Check if resultTask was already aborted before encoding\n        if (resultTask.state.stage !== 0 /* Pending */) {\n          return;\n        }\n        this.encodeImage(rawImageData, options, resultTask);\n      },\n      (error) => {\n        // Only forward error if resultTask is still pending\n        if (resultTask.state.stage === 0 /* Pending */) {\n          resultTask.fail(error);\n        }\n      },\n    );\n\n    return resultTask;\n  }\n\n  /**\n   * Encode image using encoder pool or inline\n   */\n  private encodeImage(\n    rawImageData: ImageDataLike,\n    options: any,\n    resultTask: Task<T, PdfErrorReason>,\n  ): void {\n    const imageType = options?.imageType ?? 'image/webp';\n    const quality = options?.quality;\n\n    // Convert to plain object for encoding\n    const plainImageData = {\n      data: new Uint8ClampedArray(rawImageData.data),\n      width: rawImageData.width,\n      height: rawImageData.height,\n    };\n\n    this.options\n      .imageConverter(() => plainImageData, imageType, quality)\n      .then((result) => resultTask.resolve(result))\n      .catch((error) => resultTask.reject({ code: PdfErrorCode.Unknown, message: String(error) }));\n  }\n\n  // ========== Annotations ==========\n\n  getPageAnnotations(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfAnnotationObject[]> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getPageAnnotations(doc, page),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'getPageAnnotations' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  createPageAnnotation<A extends PdfAnnotationObject>(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: A,\n    context?: AnnotationCreateContext<A>,\n  ): PdfTask<string> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.createPageAnnotation(doc, page, annotation, context),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'createPageAnnotation' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  updatePageAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.updatePageAnnotation(doc, page, annotation),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'updatePageAnnotation' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  removePageAnnotation(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfAnnotationObject,\n  ): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.removePageAnnotation(doc, page, annotation),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'removePageAnnotation' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  /**\n   * Get all annotations across all pages\n   * Uses batched operations to reduce queue overhead\n   */\n  getAllAnnotations(\n    doc: PdfDocumentObject,\n  ): CompoundTask<Record<number, PdfAnnotationObject[]>, PdfErrorReason, PdfAnnotationsProgress> {\n    // Chunk pages for batched processing\n    const chunks = this.chunkArray(doc.pages, 500);\n\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `getAllAnnotations: ${doc.pages.length} pages in ${chunks.length} chunks`,\n    );\n\n    // Create compound task for result aggregation\n    const compound = new CompoundTask<\n      Record<number, PdfAnnotationObject[]>,\n      PdfErrorReason,\n      PdfAnnotationsProgress\n    >({\n      aggregate: (results) => Object.assign({}, ...results),\n    });\n\n    // Create one task per chunk and wire up progress forwarding\n    chunks.forEach((chunkPages, chunkIndex) => {\n      const batchTask = this.workerQueue.enqueue(\n        {\n          execute: () => this.executor.getAnnotationsBatch(doc, chunkPages),\n          meta: { docId: doc.id, operation: 'getAnnotationsBatch', chunkSize: chunkPages.length },\n        },\n        { priority: Priority.LOW },\n      );\n\n      // Forward batch progress (per-page) to compound task\n      batchTask.onProgress((batchProgress: BatchProgress<PdfAnnotationObject[]>) => {\n        compound.progress({\n          page: batchProgress.pageIndex,\n          result: batchProgress.result,\n        });\n      });\n\n      compound.addChild(batchTask, chunkIndex);\n    });\n\n    compound.finalize();\n    return compound;\n  }\n\n  getPageTextRects(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfTextRectObject[]> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getPageTextRects(doc, page),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'getPageTextRects' },\n      },\n      {\n        priority: Priority.MEDIUM,\n      },\n    );\n  }\n\n  // ========== Search ==========\n\n  /**\n   * Search across all pages\n   * Uses batched operations to reduce queue overhead\n   */\n  searchAllPages(\n    doc: PdfDocumentObject,\n    keyword: string,\n    options?: PdfSearchAllPagesOptions,\n  ): PdfTask<SearchAllPagesResult, PdfPageSearchProgress> {\n    const flags = Array.isArray(options?.flags)\n      ? options.flags.reduce((acc, flag) => acc | flag, 0)\n      : (options?.flags ?? 0);\n\n    // Chunk pages for batched processing\n    const chunks = this.chunkArray(doc.pages, 25);\n\n    this.logger.debug(\n      LOG_SOURCE,\n      LOG_CATEGORY,\n      `searchAllPages: ${doc.pages.length} pages in ${chunks.length} chunks`,\n    );\n\n    // Create compound task for result aggregation\n    const compound = new CompoundTask<SearchAllPagesResult, PdfErrorReason, PdfPageSearchProgress>({\n      aggregate: (results) => {\n        // Merge all batch results into a flat array\n        const allResults = results.flatMap((batchResult: Record<number, SearchResult[]>) =>\n          Object.values(batchResult).flat(),\n        );\n        return { results: allResults, total: allResults.length };\n      },\n    });\n\n    // Create one task per chunk and wire up progress forwarding\n    chunks.forEach((chunkPages, chunkIndex) => {\n      const batchTask = this.workerQueue.enqueue(\n        {\n          execute: () => this.executor.searchBatch(doc, chunkPages, keyword, flags),\n          meta: { docId: doc.id, operation: 'searchBatch', chunkSize: chunkPages.length },\n        },\n        { priority: Priority.LOW },\n      );\n\n      // Forward batch progress (per-page) to compound task\n      batchTask.onProgress((batchProgress: BatchProgress<SearchResult[]>) => {\n        compound.progress({\n          page: batchProgress.pageIndex,\n          results: batchProgress.result,\n        });\n      });\n\n      compound.addChild(batchTask, chunkIndex);\n    });\n\n    compound.finalize();\n    return compound;\n  }\n\n  // ========== Attachments ==========\n\n  getAttachments(doc: PdfDocumentObject): PdfTask<PdfAttachmentObject[]> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getAttachments(doc),\n        meta: { docId: doc.id, operation: 'getAttachments' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  addAttachment(doc: PdfDocumentObject, params: PdfAddAttachmentParams): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.addAttachment(doc, params),\n        meta: { docId: doc.id, operation: 'addAttachment' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  removeAttachment(doc: PdfDocumentObject, attachment: PdfAttachmentObject): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.removeAttachment(doc, attachment),\n        meta: { docId: doc.id, operation: 'removeAttachment' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  readAttachmentContent(\n    doc: PdfDocumentObject,\n    attachment: PdfAttachmentObject,\n  ): PdfTask<ArrayBuffer> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.readAttachmentContent(doc, attachment),\n        meta: { docId: doc.id, operation: 'readAttachmentContent' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  // ========== Forms ==========\n\n  setFormFieldValue(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    annotation: PdfWidgetAnnoObject,\n    value: FormFieldValue,\n  ): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.setFormFieldValue(doc, page, annotation, value),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'setFormFieldValue' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  flattenPage(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    options?: PdfFlattenPageOptions,\n  ): PdfTask<PdfPageFlattenResult> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.flattenPage(doc, page, options),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'flattenPage' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  // ========== Text Operations ==========\n\n  extractPages(doc: PdfDocumentObject, pageIndexes: number[]): PdfTask<ArrayBuffer> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.extractPages(doc, pageIndexes),\n        meta: { docId: doc.id, pageIndexes: pageIndexes, operation: 'extractPages' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  extractText(doc: PdfDocumentObject, pageIndexes: number[]): PdfTask<string> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.extractText(doc, pageIndexes),\n        meta: { docId: doc.id, pageIndexes: pageIndexes, operation: 'extractText' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  redactTextInRects(\n    doc: PdfDocumentObject,\n    page: PdfPageObject,\n    rects: Rect[],\n    options?: PdfRedactTextOptions,\n  ): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.redactTextInRects(doc, page, rects, options),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'redactTextInRects' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  getTextSlices(doc: PdfDocumentObject, slices: PageTextSlice[]): PdfTask<string[]> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getTextSlices(doc, slices),\n        meta: { docId: doc.id, slices: slices, operation: 'getTextSlices' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  getPageGlyphs(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfGlyphObject[]> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getPageGlyphs(doc, page),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'getPageGlyphs' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  getPageGeometry(doc: PdfDocumentObject, page: PdfPageObject): PdfTask<PdfPageGeometry> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.getPageGeometry(doc, page),\n        meta: { docId: doc.id, pageIndex: page.index, operation: 'getPageGeometry' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  // ========== Document Operations ==========\n\n  merge(files: PdfFile[]): PdfTask<PdfFile> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.merge(files),\n        meta: { docId: files.map((file) => file.id).join(','), operation: 'merge' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  mergePages(mergeConfigs: Array<{ docId: string; pageIndices: number[] }>): PdfTask<PdfFile> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.mergePages(mergeConfigs),\n        meta: {\n          docId: mergeConfigs.map((config) => config.docId).join(','),\n          operation: 'mergePages',\n        },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  preparePrintDocument(doc: PdfDocumentObject, options?: PdfPrintOptions): PdfTask<ArrayBuffer> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.preparePrintDocument(doc, options),\n        meta: { docId: doc.id, operation: 'preparePrintDocument' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  saveAsCopy(doc: PdfDocumentObject): PdfTask<ArrayBuffer> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.saveAsCopy(doc),\n        meta: { docId: doc.id, operation: 'saveAsCopy' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  closeDocument(doc: PdfDocumentObject): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.closeDocument(doc),\n        meta: { docId: doc.id, operation: 'closeDocument' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n\n  closeAllDocuments(): PdfTask<boolean> {\n    return this.workerQueue.enqueue(\n      {\n        execute: () => this.executor.closeAllDocuments(),\n        meta: { operation: 'closeAllDocuments' },\n      },\n      { priority: Priority.MEDIUM },\n    );\n  }\n}\n"],"names":["ImageConverterError","Error","constructor","message","super","this","name","browserImageDataToBlobConverter","getImageData","imageType","quality","document","Promise","reject","pdfImage","imageData","ImageData","data","width","height","resolve","canvas","createElement","getContext","putImageData","toBlob","blob","createHybridImageConverter","workerPool","async","dataCopy","Uint8ClampedArray","encode","error","console","warn","LOG_SOURCE$1","LOG_CATEGORY$1","Priority","Priority2","WorkerTaskQueue","options","queue","running","resultTasks","Map","idleListeners","Set","concurrency","comparator","ranker","onIdle","maxQueueSize","autoStart","logger","NoopLogger","opts","Math","max","Number","POSITIVE_INFINITY","setComparator","setRanker","size","length","inFlight","isIdle","drain","check","offIdle","notifyIdle","forEach","fn","clear","add","delete","enqueue","taskDef","id","generateId","priority","resultTask","Task","set","queuedTask","meta","executeFactory","execute","push","debug","originalAbort","abort","bind","reason","cancel","process","fifo","taskId","before","filter","t","cancelled","kick","queueMicrotask","sortQueue","shift","get","realTask","wait","result","state","stage","type","onProgress","progress","toPromise","catch","sort","rankCache","getRank","has","defaultRank","a","b","ar","br","extractTime","_task","crypto","randomUUID","Date","now","random","toString","slice","split","isFinite","LOG_SOURCE","LOG_CATEGORY","PdfEngine","executor","imageConverter","fetcher","fetch","url","init","workerQueue","chunkArray","items","chunkSize","chunks","i","isSupport","feature","task","PdfEngineOperation","Create","Read","Update","Delete","destroy","code","PdfErrorCode","Unknown","String","openDocumentUrl","file","response","requestOptions","arrayBuf","arrayBuffer","pdfFile","content","openDocumentBuffer","password","doc","fail","docId","operation","CRITICAL","getMetadata","MEDIUM","setMetadata","metadata","getDocPermissions","getDocUserPermissions","getSignatures","getBookmarks","setBookmarks","bookmarks","deleteBookmarks","renderPage","page","renderWithEncoding","renderPageRaw","index","renderPageRect","rect","HIGH","renderThumbnail","renderThumbnailRaw","renderPageAnnotation","annotation","renderPageAnnotationRaw","renderFn","pageIndex","renderHandle","rawImageData","encodeImage","plainImageData","then","getPageAnnotations","createPageAnnotation","context","updatePageAnnotation","removePageAnnotation","getAllAnnotations","pages","compound","CompoundTask","aggregate","results","Object","assign","chunkPages","chunkIndex","batchTask","getAnnotationsBatch","LOW","batchProgress","addChild","finalize","getPageTextRects","searchAllPages","keyword","flags","Array","isArray","reduce","acc","flag","allResults","flatMap","batchResult","values","flat","total","searchBatch","getAttachments","addAttachment","params","removeAttachment","attachment","readAttachmentContent","setFormFieldValue","value","flattenPage","extractPages","pageIndexes","extractText","redactTextInRects","rects","getTextSlices","slices","getPageGlyphs","getPageGeometry","merge","files","map","join","mergePages","mergeConfigs","config","preparePrintDocument","saveAsCopy","closeDocument","closeAllDocuments"],"ignoreList":[],"sourceRoot":""}